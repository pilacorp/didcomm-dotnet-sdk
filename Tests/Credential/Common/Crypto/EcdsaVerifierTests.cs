using System;
using Pila.CredentialSdk.DidComm.Credential.Common.Crypto;
using Xunit;

namespace Pila.CredentialSdk.DidComm.Tests.Credential.Common.Crypto;

public class EcdsaVerifierTests
{
    // Data captured from a known-good signature generated by the Go SDK (layout [r||s||v])
    private const string PublicKeyHex = "02b35b116329ad5ce292030a63deac8a75428d0029325500aac957bfdb63273746";
    private const string SignatureHex = "a7a970560732bf2e2cb4a02b4a566e12adc658e57aac871f1399c2d4532f2d0037186ae3173990a3d98dec31e518e03efb1e7ea438d919babc9974356def26d000";
    private static readonly byte[] Message = Convert.FromHexString("68adb8f4bbb2a88c65d57b9aa40f66871fe89a3315a98d6d65d2a298988f1f5c");

    [Fact]
    public void VerifySignature_WithRsvSignature_Succeeds()
    {
        var result = EcdsaVerifier.VerifySignature(PublicKeyHex, SignatureHex, Message);

        Assert.True(result);
    }

    [Fact]
    public void VerifySignature_WithTamperedMessage_Fails()
    {
        var tampered = (byte[])Message.Clone();
        tampered[^1] ^= 0xFF;

        var result = EcdsaVerifier.VerifySignature(PublicKeyHex, SignatureHex, tampered);

        Assert.False(result);
    }
}

